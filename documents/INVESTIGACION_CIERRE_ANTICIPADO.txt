"""
REPORTE DE INVESTIGACIÃ“N: CIERRE ANTICIPADO DE POSICIONES
==========================================================

FECHA: 2025-10-20
INVESTIGADOR: Sistema de Trading AlgorÃ­tmico
OBJETIVO: Entender por quÃ© NINGUNA posiciÃ³n cerrÃ³ anticipadamente

==========================================================
HALLAZGOS DE LA INVESTIGACIÃ“N
==========================================================

1. FLUJO DEL BACKTESTER âœ…
--------------------------

El backtester sigue este flujo en cada dÃ­a de trading:

1. Loop por cada fecha en trading_dates
2. Llama a _manage_positions() â† AQUÃ SE CHECA
3. Llama a _find_new_opportunities() (solo viernes)
4. Registra equity del dÃ­a

Por lo tanto, SÃ estÃ¡ checando posiciones en cada dÃ­a.


2. CÃ“DIGO DE PROFIT TARGET (LÃ­nea 620)
---------------------------------------

```python
# Verificar profit target
if current_pnl >= position.profit_target:
    position.pnl = current_pnl
    position.exit_date = current_date
    position.exit_value = current_value
    position.days_held = (current_date - position.entry_date).days
    position.status = 'closed_profit'
    positions_to_close.append(position)
    continue
```

âœ… CORRECTO: Cierra cuando current_pnl >= profit_target


3. CÃ“DIGO DE STOP LOSS (LÃ­nea 631)
-----------------------------------

```python
# Verificar stop loss
if current_pnl <= -position.stop_loss:
    position.pnl = current_pnl
    position.exit_date = current_date
    position.exit_value = current_value
    position.days_held = (current_date - position.entry_date).days
    position.status = 'closed_loss'
    positions_to_close.append(position)
    continue
```

âœ… CORRECTO: Cierra cuando current_pnl <= -stop_loss


4. CÃLCULO DE CURRENT_PNL (LÃ­nea 616)
--------------------------------------

```python
# Calcular PnL actual (para Iron Condor: crÃ©dito recibido - valor actual)
current_pnl = position.premium_collected - current_value
```

âœ… CORRECTO: 
- Iron Condor vendido (crÃ©dito)
- PnL = Premium recibido - Valor actual de las opciones
- Si valor actual baja â†’ PnL sube (bueno)
- Si valor actual sube â†’ PnL baja (malo)


5. VALORACIÃ“N CON _calculate_position_value() âš ï¸
-------------------------------------------------

```python
# Calcular valor actual de la posiciÃ³n
current_value = self._calculate_position_value(
    ticker, position, current_date, underlying_price
)

# DEBUG: Ver quÃ© estÃ¡ pasando con la valoraciÃ³n
days_remaining = (position.expiration_date - current_date).days
if current_value is None:
    continue  â† Â¡AQUÃ ESTÃ EL PROBLEMA!
```

ðŸš¨ PROBLEMA CRÃTICO IDENTIFICADO:

Si _calculate_position_value() retorna None, el cÃ³digo hace `continue`
y SALTA la verificaciÃ³n de profit target y stop loss!


6. Â¿CUÃNDO RETORNA None? (LÃ­nea 720-790)
-----------------------------------------

_calculate_position_value() retorna None cuando:

a) No hay datos para esa fecha/vencimiento:
```python
if len(available_options) == 0:
    return None
```

b) No se encuentran TODAS las legs:
```python
if legs_found == len(position.legs):
    return total_value
else:
    # Si falta alguna leg, no podemos valorar correctamente
    return None  â† Â¡PROBLEMA!
```

ðŸš¨ HALLAZGO CLAVE:

Si alguna de las 4 legs del Iron Condor no tiene datos en un snapshot,
la funciÃ³n retorna None y se SALTA la verificaciÃ³n de targets/stops.


7. Â¿POR QUÃ‰ FALTAN DATOS DE LEGS?
-----------------------------------

Posibles razones:

a) LIQUIDEZ: Opciones muy OTM pueden no tener volumen/precio en algunos dÃ­as
b) POLYGON DATA: Puede que no todos los strikes tengan datos en todos los snapshots
c) BID-ASK: Si close = NaN y vwap = NaN, la leg no tiene precio

Esto explicarÃ­a por quÃ©:
- Las posiciones NO cierran anticipadamente
- Todas llegan a vencimiento (donde usa valor intrÃ­nseco, no market data)


==========================================================
CONCLUSIÃ“N PRINCIPAL
==========================================================

ðŸŽ¯ PROBLEMA IDENTIFICADO:

El backtester SÃ checa profit targets y stop losses en cada dÃ­a,
pero SOLO si puede valorar TODAS las legs de la posiciÃ³n.

Si alguna leg no tiene datos (comÃºn en opciones OTM con baja liquidez),
el cÃ³digo hace `continue` y NO evalÃºa si debe cerrar.

Esto es especialmente problemÃ¡tico para Iron Condors porque tienen
4 legs (2 calls, 2 puts), multiplicando la probabilidad de que
alguna no tenga datos.


==========================================================
EVIDENCIA DE LOS DATOS
==========================================================

De tu anÃ¡lisis:
- 20/20 trades llegaron a vencimiento
- Ninguno cerrÃ³ por profit_target
- Ninguno cerrÃ³ por stop_loss
- Todas las posiciones tienen status = 'closed_end' (expired)

Esto es consistente con mi hallazgo:
â†’ Las legs OTM no tienen datos suficientes
â†’ current_value retorna None
â†’ Se salta el chequeo de targets/stops
â†’ Solo cierra al vencimiento (usa valor intrÃ­nseco, no market data)


==========================================================
IMPLICACIONES
==========================================================

1. TUS RESULTADOS SON OPTIMISTAS
   - No estÃ¡s capturando cierres por profit (dejarÃ­as dinero en la mesa)
   - No estÃ¡s capturando stops (podrÃ­as tener peores pÃ©rdidas)
   - Los retornos reales podrÃ­an ser diferentes

2. GLD (92% return) PODRÃA SER DIFERENTE
   - Si hubiera cerrado en 50% profit target
   - Solo hubiera ganado ~46% (no 92%)
   - Pero cerrarÃ­a mÃ¡s rÃ¡pido (libera capital antes)

3. LA OPTIMIZACIÃ“N NECESITA ESTE FIX PRIMERO
   - No puedes optimizar profit targets si nunca se evalÃºan
   - Los datos de ML estÃ¡n sesgados (solo expiraciones)


==========================================================
RECOMENDACIONES
==========================================================

OPCIÃ“N A: FIX CONSERVADOR â­ RECOMENDADO
----------------------------------------
Usar modelo de valoraciÃ³n cuando faltan datos de mercado:

```python
if current_value is None:
    # Fallback: estimar valor con Black-Scholes
    current_value = self._estimate_value_with_model(
        position, current_date, underlying_price
    )
```

PROS:
- Permite evaluar targets/stops siempre
- Usa modelo cuantitativo (ya tienes BSM)
- MÃ¡s realista que ignorar

CONS:
- Menos preciso que precio real
- Requiere implementar funciÃ³n


OPCIÃ“N B: FIX AGRESIVO
-----------------------
Asumir valor = 0 para legs sin datos (muy OTM):

```python
if current_value is None:
    # Asumir que opciones muy OTM valen ~0
    current_value = 0
```

PROS:
- Simple
- Conservador

CONS:
- Impreciso
- Puede causar cierres prematuros incorrectos


OPCIÃ“N C: FIX MÃNIMO
---------------------
Al menos registrar cuando no puede valorar:

```python
if current_value is None:
    self.valorization_failures += 1
    continue
```

PROS:
- MÃ­nimo cambio
- DiagnÃ³stico

CONS:
- No resuelve el problema


==========================================================
PRÃ“XIMO PASO RECOMENDADO
==========================================================

1. Implementar OPCIÃ“N A (FIX CONSERVADOR)
   - Agregar funciÃ³n _estimate_value_with_model()
   - Usar Black-Scholes para estimar valor
   - Usar esto como fallback cuando faltan datos

2. Agregar logging para ver cuÃ¡ntas veces pasa
   
3. Re-correr backtest y comparar resultados

4. DespuÃ©s continuar con optimizaciÃ³n de scoring


==========================================================
CÃ“DIGO A MODIFICAR
==========================================================

Archivo: backtester.py
FunciÃ³n: _manage_positions()
LÃ­neas: ~611-620

ANTES:
```python
if current_value is None:
    continue
```

DESPUÃ‰S:
```python
if current_value is None:
    # Fallback: estimar con modelo
    current_value = self._estimate_value_with_model(
        position, current_date, underlying_price
    )
    if current_value is None:
        continue  # Si aÃºn no podemos valorar, skip
```

Agregar nueva funciÃ³n:
```python
def _estimate_value_with_model(self, position, current_date, underlying_price):
    # Usar Black-Scholes para estimar valor de cada leg
    # Sumar para obtener valor total
    pass
```


==========================================================
FIN DEL REPORTE
==========================================================
"""
